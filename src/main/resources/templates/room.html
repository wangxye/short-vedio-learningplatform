<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style type="text/css">
        body {
            font-family: Monospace;
            color: #fff;
            margin: 0px;
            overflow: hidden;
            background-color: #E9E9E9;

            background-size: cover;
            -moz-background-size: cover;
            -webkit-background-size: cover;
            -o-background-size: cover;
        }

        html, body {
            margin: 0;
            padding: 0;
        }



    </style>
</head>
<body onload="draw();">
<canvas id="canvas" style="display: none;">你的浏览器不支持canvas</canvas>
<div id="WebGL-output"></div>
<div id="Stats-output"></div>

<div id="label"></div>
</body>
<script src="jquery-3.5.1/jquery-3.5.1.min.js"></script>
<script src="js1/three.js"></script>
<script src="js1/loaders/OBJLoader.js"></script>
<script src="js1/controls/OrbitControls.js"></script>
<script src="js1/libs/stats.min.js"></script>
<script src="js1/libs/dat.gui.min.js"></script>
<script src="js1/loaders/MTLLoader.js"></script>
<script src="js1/loaders/DDSLoader.js"></script>
<script src="js1/controls/TrackballControls.js"></script>
<script src="js1/WebGL.js"></script>
<script>
    var renderer;
    var objs = [];

    function initRender() {
        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        //告诉渲染器需要阴影效果
        renderer.setClearColor(0xffffff);
        document.body.appendChild(renderer.domElement);
    }

    var camera;

    function initCamera() {
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 40, 50);
        camera.lookAt(new THREE.Vector3(0, 0, 0));
    }

    var scene;

    function initScene() {
        scene = new THREE.Scene();
    }

    //初始化dat.GUI简化试验流程
    var gui;

    function initGui() {
        //声明一个保存需求修改的相关数据的对象
        gui = {};
        var datGui = new dat.GUI();
        //将设置属性添加到gui当中，gui.add(对象，属性，最小值，最大值）
    }

    var light;

    function initLight() {
        scene.add(new THREE.AmbientLight(0xaaaaaa));

        light = new THREE.PointLight(0xffffff);
        light.position.set(0, 100,);

        //告诉平行光需要开启阴影投射
        light.castShadow = true;

        scene.add(light);
    }

    function initModel() {

// model
        var onProgress = function (xhr) {
            console.log(xhr)
            if (xhr.lengthComputable) {
                var percentComplete = xhr.loaded / xhr.total * 100;
                console.log(Math.round(percentComplete, 2) + '% downloaded');
            }
        };

        var onError = function (xhr) {
        };

        THREE.Loader.Handlers.add(/\.dds$/i, new THREE.DDSLoader());

        var mtlLoader = new THREE.MTLLoader();
        mtlLoader.setPath('models2/');
        mtlLoader.load('renwu.mtl', function (materials) {

            materials.preload();

            var objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(materials);
            objLoader.setPath('models2/');
            objLoader.load('renwu.obj', function (object) {
                object.name = "renwu";
                object.position.y = -0.5;
                object.scale.set(3, 3, 3);
                scene.add(object);

            }, onProgress, onError);

        });
        var mtlLoader = new THREE.MTLLoader();
        mtlLoader.setPath('models2/');
        mtlLoader.load('pingmian.mtl', function (materials) {

            materials.preload();

            var objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(materials);
            objLoader.setPath('models2/');
            objLoader.load('pingmian.obj', function (object) {
                object.name = "pingmian";
                object.position.y = -0.5;
                object.scale.set(3, 3, 3);
                scene.add(object);

            }, onProgress, onError);

        });
        var mtlLoader = new THREE.MTLLoader();
        mtlLoader.setPath('models2/');
        mtlLoader.load('shujia.mtl', function (materials) {

            materials.preload();

            var objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(materials);
            objLoader.setPath('models2/');
            objLoader.load('shujia.obj', function (object) {
                object.name = "shujia";
                object.position.y = -0.5;
                object.scale.set(3, 3, 3);
                scene.add(object);

            }, onProgress, onError);

        });
        var mtlLoader = new THREE.MTLLoader();
        mtlLoader.setPath('models2/');
        mtlLoader.load('zhuomian1.mtl', function (materials) {

            materials.preload();

            var objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(materials);
            objLoader.setPath('models2/');
            objLoader.load('zhuomian1.obj', function (object) {
                object.name = "zhuomian1";
                object.position.y = -0.5;
                object.scale.set(3, 3, 3);
                scene.add(object);

            }, onProgress, onError);

        });
        var mtlLoader = new THREE.MTLLoader();
        mtlLoader.setPath('models2/');
        mtlLoader.load('zhuomian2.mtl', function (materials) {

            materials.preload();

            var objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(materials);
            objLoader.setPath('models2/');
            objLoader.load('zhuomian2.obj', function (object) {
                object.name = "zhuomian2";
                object.position.y = -0.5;
                object.scale.set(3, 3, 3);
                scene.add(object);

            }, onProgress, onError);

        });
        var mtlLoader = new THREE.MTLLoader();
        mtlLoader.setPath('models2/');
        mtlLoader.load('pingmu.mtl', function (materials) {

            materials.preload();

            var objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(materials);
            objLoader.setPath('models2/');
            objLoader.load('pingmu.obj', function (object) {
                object.name = "pingmu";
                object.position.y = -0.5;
                object.scale.set(3, 3, 3);
                scene.add(object);

            }, onProgress, onError);

        });
        var mtlLoader = new THREE.MTLLoader();
        mtlLoader.setPath('models2/');
        mtlLoader.load('dianzishu.mtl', function (materials) {

            materials.preload();

            var objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(materials);
            objLoader.setPath('models2/');
            objLoader.load('dianzishu.obj', function (object) {
                object.name = "dianzishu";
                object.position.y = -0.5;
                object.scale.set(3, 3, 3);
                scene.add(object);

            }, onProgress, onError);

        });
        var mtlLoader = new THREE.MTLLoader();
        mtlLoader.setPath('models2/');
        mtlLoader.load('book1.mtl', function (materials) {

            materials.preload();

            var objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(materials);
            objLoader.setPath('models2/');
            objLoader.load('book1.obj', function (object) {
                object.name = "book1";
                object.position.y = -0.5;
                object.scale.set(3, 3, 3);
                scene.add(object);

            }, onProgress, onError);

        });
    }

    //初始化性能插件
    var stats;

    function initStats() {
        stats = new Stats();
        document.body.appendChild(stats.dom);
    }

    //用户交互插件 鼠标左键按住旋转，右键按住平移，滚轮缩放
    var controls;

    function initControls() {

        controls = new THREE.OrbitControls(camera, renderer.domElement);

        // 如果使用animate方法时，将此函数删除
        //controls.addEventListener( 'change', render );
        // 使动画循环使用时阻尼或自转 意思是否有惯性
        controls.enableDamping = true;
        //动态阻尼系数 就是鼠标拖拽旋转灵敏度
        //controls.dampingFactor = 0.25;
        //是否可以缩放
        controls.enableZoom = true;
        //是否自动旋转
        //controls.autoRotate = true;
        //设置相机距离原点的最远距离
        controls.minDistance = 1;
        //设置相机距离原点的最远距离
        controls.maxDistance = 200;
        //是否开启右键拖拽
        controls.enablePan = true;
    }

    function render() {

        renderer.render(scene, camera);
    }

    //窗口变动触发的函数
    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        render();
        renderer.setSize(window.innerWidth, window.innerHeight);

    }

    function animate() {
        //更新控制器
        render();


        //更新性能插件
        stats.update();

        controls.update();

        requestAnimationFrame(animate);
    }

    function draw() {
        initGui();
        initRender();
        initScene();
        initCamera();
        initLight();
        initModel();
        initControls();
        initStats();

        animate();
        window.onresize = onWindowResize;
    }

    function onMouseClick(event) {
        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2();
        //通过鼠标点击的位置计算出raycaster所需要的点的位置，以屏幕中心为原点，值的范围为-1到1.

        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        // 通过鼠标点的位置和当前相机的矩阵计算出raycaster
        raycaster.setFromCamera(mouse, camera);
        //找到场景中所有外部模型
        var scensObjs = [];
        scene.children.forEach(child => {
            for (var i = 0; i < child.children.length; i++) {
                var obj = child.children[i];
                scensObjs.push(obj);

            }
        });
        // 获取raycaster直线和所有模型相交的数组集合
        var intersects = raycaster.intersectObjects(scensObjs);

        // console.log(intersects);

        //将所有的相交的模型的颜色设置为红色，如果只需要将第一个触发事件，那就数组的第一个模型改变颜色即可

        for (var i = 0; i < intersects.length; i++) {
            var intersect = intersects[i];
            if (intersect.object instanceof THREE.Mesh) {
                var obj = intersect.object.parent;
                //把距离加到模型用户数据里面，方便后面排序
                obj.userData.distance = intersect.distance;
                objs.push(obj);

            }

        }
        objs = objs.sort(function (a, b) {
            return a.userData.distance - b.userData.distance;

        });

        var studioId = [[${studioId}]];
        var userId = [[${userId}]];

        var strInformation = "/selfStatus?studioId=" + studioId.toString() + "&userId=" + userId.toString();
        var strStudy = "/toStudy?studioId=" + studioId.toString() + "&userId=" + userId.toString();
        if (objs[0].name == "zhuomian1") {
            location.href = "test"
        }
        ;
        if (objs[0].name == "shujia") {
            location.href = strStudy
        }
        ;
        if (objs[0].name == "zhuomian2") {
            location.href = "test"
        }
        ;
        if (objs[0].name == "dianzish") {
            location.href = "test"
        }
        ;
        if (objs[0].name == "pingmu") {
            location.href = strInformation
        }
        ;
        if (objs[0].name == "renwu") {//用canvas生成图片
            let canvas = document.getElementById('canvas')
            let ctx = canvas.getContext('2d')
            canvas.width = 300
            canvas.height = 300
            //制作矩形
            ctx.fillStyle = "rgba(255,165,0,0.8)";
            ctx.fillRect(0, 0, 300, 300)
            //设置文字
            ctx.fillStyle = "#fff";
            ctx.font = 'normal 18pt "楷体"'
            ctx.fillText('任务发布者', 100, 20)
            let textWord = '已领取任务'
            //文字换行
            let len = parseInt(textWord.length / 10)
            for (let i = 0; i < (len + 1); i++) {
                let space = 10
                if (i === len) {
                    space = textWord.length - len * 10
                }
                console.log('len+' + len, 'space+' + space)
                let word = textWord.substr(i * 10, space)
                ctx.fillText(word, 15, 60 * (i + 1))
            }
            //生成图片
            let url = canvas.toDataURL('image/png');

            //将图片构建到纹理中
            let geometry1 = new THREE.PlaneGeometry(10, 10)
            let texture = THREE.ImageUtils.loadTexture(url, null, function (t) {
            })

            let material1 = new THREE.MeshBasicMaterial({
                map: texture,
                side: THREE.DoubleSide,
                opacity: 1,
                transparent: true,
            })

            let rect = new THREE.Mesh(geometry1, material1)
            rect.position.set(16, 15, -10)
            scene.add(rect)
        }
        ;


    };


    window.addEventListener('click', onMouseClick, false);

</script>
</html>

