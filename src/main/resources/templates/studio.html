<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style type="text/css">
        body {
            font-family: Monospace;
            color: #fff;
            margin: 0px;
            overflow: hidden;
            background-color: #E9E9E9;

            background-size: cover;
            -moz-background-size: cover;
            -webkit-background-size: cover;
            -o-background-size: cover;
        }

        html, body {
            margin: 0;
            padding: 0;
        }

    </style>
</head>
<body onload="draw();">
<div id="progress" class="progress">
    <div class="mask"></div>
    <div class="loading">
        <div class="trends"></div>
    </div>
</div>
</body>
<script src="js1/three.js"></script>
<script src="js1/loaders/OBJLoader.js"></script>
<script src="js1/controls/OrbitControls.js"></script>
<script src="js1/libs/stats.min.js"></script>
<script src="js1/libs/dat.gui.min.js"></script>
<script src="js1/loaders/MTLLoader.js"></script>
<script src="js1/loaders/DDSLoader.js"></script>
<script src="js1/controls/TrackballControls.js"></script>
<script src="js1/WebGL.js"></script>
<script src="js1/three_sprite_utils.js"></script>
<script th:inline="javascript">
    var renderer;

    function initRender() {
        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        //告诉渲染器需要阴影效果
        renderer.setClearColor(0xffffff);
        document.body.appendChild(renderer.domElement);
    }

    var camera;

    function initCamera() {
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 600, 260);
        camera.lookAt(new THREE.Vector3(0, 0, 0));
    }

    var scene;

    function initScene() {
        scene = new THREE.Scene();
    }

    //初始化dat.GUI简化试验流程
    var gui;

    function initGui() {
        //声明一个保存需求修改的相关数据的对象
        gui = {};
        var datGui = new dat.GUI();
        //将设置属性添加到gui当中，gui.add(对象，属性，最小值，最大值）
    }

    var light;

    function initLight() {
        scene.add(new THREE.AmbientLight(0xffffff));

        light = new THREE.PointLight(0xffffff);
        light.position.set(0, 100,);

        //告诉平行光需要开启阴影投射
        light.castShadow = true;

        scene.add(light);
    }

    function initModel() {

// model
        var onProgress = function (xhr) {
            console.log(xhr)
            if (xhr.lengthComputable) {
                var percentComplete = xhr.loaded / xhr.total * 100;
                console.log(Math.round(percentComplete, 2) + '% downloaded');
            }
        };

        var onError = function (xhr) {
        };

        THREE.Loader.Handlers.add(/\.dds$/i, new THREE.DDSLoader());

        var mtlLoader = new THREE.MTLLoader();
        mtlLoader.setPath('models/test/');
        mtlLoader.load('model1.mtl', function (materials) {

            materials.preload();

            var objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(materials);
            objLoader.setPath('models/test/');
            objLoader.load('model1.obj', function (object) {
                object.name = "model1";
                object.position.y = -0.5;
                object.scale.set(3, 3, 3);
                scene.add(object);


                const model1Div = document.createElement('div');
                model1Div.className = 'label';
                model1Div.textContent = 'model1';
                model1Div.style.marginTop = '-1em';
                const model1Label = new THREE.CSS2DObject(model1Div);
                model1Label.position.set(10, 10, 10);
                object.add(model1Label);

            }, onProgress, onError);

        });
        mtlLoader.load('model2.mtl', function (materials) {

            materials.preload();

            var objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(materials);
            objLoader.setPath('models/test/');
            objLoader.load('model2.obj', function (object) {
                object.name = "model2";
                object.position.y = -0.5;
                object.scale.set(3, 3, 3);
                scene.add(object);

            }, onProgress, onError);

        });
        mtlLoader.load('model3.mtl', function (materials) {

            materials.preload();

            var objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(materials);
            objLoader.setPath('models/test/');
            objLoader.load('model3.obj', function (object) {
                object.name = "model3";
                object.position.y = -0.5;
                object.scale.set(3, 3, 3);
                scene.add(object);

            }, onProgress, onError);

        });
        mtlLoader.load('model4.mtl', function (materials) {

            materials.preload();

            var objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(materials);
            objLoader.setPath('models/test/');
            objLoader.load('model4.obj', function (object) {
                object.name = "model4";
                object.position.y = -0.5;
                object.scale.set(3, 3, 3);
                scene.add(object);

            }, onProgress, onError);

        });
        mtlLoader.load('model5.mtl', function (materials) {

            materials.preload();

            var objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(materials);
            objLoader.setPath('models/test/');
            objLoader.load('model5.obj', function (object) {
                object.name = "model5";
                object.position.y = -0.5;
                object.scale.set(3, 3, 3);
                scene.add(object);

            }, onProgress, onError);

        });
        mtlLoader.load('model6.mtl', function (materials) {

            materials.preload();

            var objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(materials);
            objLoader.setPath('models/test/');
            objLoader.load('model6.obj', function (object) {
                object.name = "model6";
                object.position.y = -0.5;
                object.scale.set(3, 3, 3);
                scene.add(object);

            }, onProgress, onError);

        });
        mtlLoader.load('model7.mtl', function (materials) {

            materials.preload();

            var objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(materials);
            objLoader.setPath('models/test/');
            objLoader.load('model7.obj', function (object) {
                object.name = "model7";
                object.position.y = -0.5;
                object.scale.set(3, 3, 3);
                scene.add(object);

            }, onProgress, onError);

        });

    }

    //初始化性能插件
    var stats;

    function initStats() {
        stats = new Stats();
        document.body.appendChild(stats.dom);
    }

    //用户交互插件 鼠标左键按住旋转，右键按住平移，滚轮缩放
    var controls;

    function initControls() {

        controls = new THREE.OrbitControls(camera, renderer.domElement);

        // 如果使用animate方法时，将此函数删除
        //controls.addEventListener( 'change', render );
        // 使动画循环使用时阻尼或自转 意思是否有惯性
        controls.enableDamping = true;
        //动态阻尼系数 就是鼠标拖拽旋转灵敏度
        //controls.dampingFactor = 0.25;
        //是否可以缩放
        controls.enableZoom = true;
        //是否自动旋转
        //controls.autoRotate = true;
        //设置相机距离原点的最远距离
        controls.minDistance = 1;
        //设置相机距离原点的最远距离
        controls.maxDistance = 2000;
        //是否开启右键拖拽
        controls.enablePan = true;
    }

    function render() {

        renderer.render(scene, camera);
    }

    //窗口变动触发的函数
    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        render();
        renderer.setSize(window.innerWidth, window.innerHeight);

    }

    function animate() {
        //更新控制器
        render();

        //更新性能插件
        stats.update();

        controls.update();

        requestAnimationFrame(animate);
    }


    function makeLabelCanvas(baseWidth, size, name) {
        const ctx = document.createElement('canvas').getContext('2d');
        const boderSize = 2;
        const font = `${size}px bold sans-serif`;
        ctx.font = font;
        const textWidth = ctx.measureText(name).width;

        const doubleBorderSize = boderSize * 2;
        const width = baseWidth + doubleBorderSize;
        const height = size + doubleBorderSize;
        ctx.canvas.width = width;
        ctx.canvas.height = height;

        ctx.font = font;
        ctx.textBaseline = 'middle';
        ctx.textAlign = 'center';

        ctx.fillStyle = 'blue';
        ctx.fillRect(0, 0, width, height);

        // scale to fit but don't stretch
        const scaleFactor = Math.min(1, baseWidth / textWidth);
        ctx.translate(width / 2, height / 2);
        ctx.scale(scaleFactor, 1);
        ctx.fillStyle = 'white';
        ctx.fillText(name, 0, 0);

        return ctx.canvas;
    }

    var studios = [[${studios}]];

    function addPeople() {
        // var floors = [[${floors}]];
        // makePerson(11, -13, 5, floors[0].floor_name, floors[0].id);
        var changdu = studios.length;
        if (changdu > 0)
            makePerson(-12, 90, -100, studios[0].name, studios[0].studio_id, 0, 1, 0);
        if (changdu > 1)
            makePerson(34, 75, -106, studios[1].name, studios[1].studio_id, 0, 1, 0);
        if (changdu > 2)
            makePerson(76, 90, -90, studios[2].name, studios[2].studio_id, 0, 1, 0);
        if (changdu > 3)
            makePerson(56, 90, 126, studios[3].name, studios[3].studio_id, 0, 0, 0);
        if (changdu > 4)
            makePerson(-12, 90, 120, studios[4].name, studios[4].studio_id, 0, 0, 0);
        if (changdu > 5)
            makePerson(-123, 113, 5, studios[5].name, studios[5].studio_id, 0, 1.5, 2);
    }

    function makePerson(x, y, z, name, id, rx, ry, rz) {
        const canvas = makeLabelCanvas(150, 50, name);
        const bodyRadiusTop = .4;
        const bodyRadiusBottom = .2;
        const bodyHeight = 2;
        const bodyRadialSegments = 6;
        const bodyGeometry = new THREE.CylinderGeometry(
            bodyRadiusTop, bodyRadiusBottom, bodyHeight, bodyRadialSegments);

        const headRadius = bodyRadiusTop * 0.8;
        const headLonSegments = 12;
        const headLatSegments = 5;
        const headGeometry = new THREE.SphereGeometry(
            headRadius, headLonSegments, headLatSegments);

        const labelGeometry = new THREE.PlaneGeometry(1, 1);
        const texture = new THREE.CanvasTexture(canvas);
        const labelMaterial = new THREE.MeshBasicMaterial({
            map: texture,
            side: THREE.DoubleSide,
            transparent: true,
        });
        const bodyMaterial = new THREE.MeshPhongMaterial({
            color: "purple",
            flatShading: true,
        });

        const root = new THREE.Object3D();
        root.position.x = x;

        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);

        const head = new THREE.Mesh(headGeometry, bodyMaterial);

        const label = new THREE.Mesh(labelGeometry, labelMaterial);
        label.rotation.x = Math.PI * rx;
        label.rotation.y = Math.PI * ry;
        label.rotation.z = Math.PI * rz;
        root.add(label);
        label.position.x = x;
        label.position.y = y;
        label.position.z = z;

        const labelBaseScale = 0.60;
        label.scale.x = canvas.width * labelBaseScale;
        label.scale.y = canvas.height * labelBaseScale;


        //this.clickObjects.push(root);
        head.name = id;
        body.name = id;

        scene.add(root);
    }

    function draw() {
        // alert("建议旋转场景在模型之外");
        initGui();
        initRender();
        initScene();
        initCamera();
        initLight();
        initModel();
        initControls();
        initStats();

        animate();
        addPeople();

        window.onresize = onWindowResize;
    }

    function onMouseClick(event) {
        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2();
        //通过鼠标点击的位置计算出raycaster所需要的点的位置，以屏幕中心为原点，值的范围为-1到1.

        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        // 通过鼠标点的位置和当前相机的矩阵计算出raycaster
        raycaster.setFromCamera(mouse, camera);
        //找到场景中所有外部模型
        var scensObjs = [];
        scene.children.forEach(child => {
            for (var i = 0; i < child.children.length; i++) {
                var obj = child.children[i];
                scensObjs.push(obj);
            }
        });
        // 获取raycaster直线和所有模型相交的数组集合
        var intersects = raycaster.intersectObjects(scensObjs);

        var intersect = intersects[0];
        if (intersect.object instanceof THREE.Mesh) {
            var obj = intersect.object.parent;
            //把距离加到模型用户数据里面，方便后面排序
            obj.userData.distance = intersect.distance;
            var str = "/room";
            var userId = [[${userId}]];

            str = str + "?userId=" + userId.toString() + "&studioId=";
            if (obj.name == "model1") {
                window.location.href = str + studios[0].studio_id.toString() + "&taskId=-1&videoId=-2&bookId=-1";
                console.log(obj.name)
            }
            if (obj.name == "model2") {
                window.location.href = str + studios[1].studio_id.toString() + "&taskId=-1&videoId=-2&bookId=-1";
                console.log(obj.name)
            }
            if (obj.name == "model3") {
                window.location.href = str + studios[2].studio_id.toString() + "&taskId=-1&videoId=-2&bookId=-1";
                console.log(obj.name)
            }
            if (obj.name == "model4") {
                window.location.href = str + studios[3].studio_id.toString() + "&taskId=-1&videoId=-2&bookId=-1";
                console.log(obj.name)
            }
            if (obj.name == "model5") {
                window.location.href = str + studios[4].studio_id.toString() + "&taskId=-1&videoId=-2&bookId=-1";
                console.log(obj.name)
            }
            if (obj.name == "model6") {
                window.location.href = str + studios[5].studio_id.toString() + "&taskId=-1&videoId=-2&bookId=-1";
                console.log(obj.name)
            }
        }
    }

    function onfirstClick(event) {
        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2();
        //通过鼠标点击的位置计算出raycaster所需要的点的位置，以屏幕中心为原点，值的范围为-1到1.

        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        // 通过鼠标点的位置和当前相机的矩阵计算出raycaster
        raycaster.setFromCamera(mouse, camera);
        //找到场景中所有外部模型
        var scensObjs = [];
        scene.children.forEach(child => {
            for (var i = 0; i < child.children.length; i++) {
                var obj = child.children[i];
                scensObjs.push(obj);
            }
        });
        // 获取raycaster直线和所有模型相交的数组集合
        var intersects = raycaster.intersectObjects(scensObjs);

        var intersect = intersects[0];
        if (intersect.object instanceof THREE.Mesh) {
            var obj = intersect.object.parent;
            //把距离加到模型用户数据里面，方便后面排序
            obj.userData.distance = intersect.distance;
            if (obj.name == "model1") {
                var selectedMesh = intersects[0].object;
                console.log(selectedMesh);
                var newSprite = SwitchSprite(studios[0].name, studios[0].content, selectedMesh.position, selectedMesh);
                console.log(selectedMesh.position);
                if (newSprite != null)
                    scene.add(newSprite);
            }
            if (obj.name == "model2") {
                var selectedMesh = intersects[0].object;
                console.log(selectedMesh);
                var newSprite = SwitchSprite(studios[1].name, studios[1].content, selectedMesh.position, selectedMesh);
                console.log(selectedMesh.position);
                if (newSprite != null)
                    scene.add(newSprite);
            }
            if (obj.name == "model3") {
                var selectedMesh = intersects[0].object;
                console.log(selectedMesh);
                var newSprite = SwitchSprite(studios[2].name, studios[2].content, selectedMesh.position, selectedMesh);
                console.log(selectedMesh.position);
                if (newSprite != null)
                    scene.add(newSprite);
            }
            if (obj.name == "model4") {
                var selectedMesh = intersects[0].object;
                console.log(selectedMesh);
                var newSprite = SwitchSprite(studios[3].name, studios[3].content, selectedMesh.position, selectedMesh);
                console.log(selectedMesh.position);
                if (newSprite != null)
                    scene.add(newSprite);
            }
            if (obj.name == "model5") {
                var selectedMesh = intersects[0].object;
                console.log(selectedMesh);
                var newSprite = SwitchSprite(studios[4].name, studios[4].content, selectedMesh.position, selectedMesh);
                console.log(selectedMesh.position);
                if (newSprite != null)
                    scene.add(newSprite);
            }
            if (obj.name == "model6") {
                var selectedMesh = intersects[0].object;
                console.log(selectedMesh);
                var newSprite = SwitchSprite(studios[5].name, studios[5].content, selectedMesh.position, selectedMesh);
                console.log(selectedMesh.position);
                if (newSprite != null)
                    scene.add(newSprite);
            }
        }
    }

    window.addEventListener('dblclick', onMouseClick, false);
    window.addEventListener('click', onfirstClick, false);
</script>
</html>

